#!/usr/bin/env node

"use strict";

const argv = require("yargs")
    .option("export", {alias: "e", describe: "If set all modules for the requested language found in root will be parsed and a export.csv will be generated."})
    .option("exportOutput", {default: "export", describe: "The file path to which the export should be written."})
    .option("format", {default: "csv", describe: "The format of the import/export operation. Supported formats are CSV and PO (case-insensitive)."})
    .option("import", {alias: "i", describe: "A CSV file to be imported and to generate code from. Generate elm files will be placed in <importOutput>."})
    .option("importOutput", {default: "import", describe: "The base directory to which the generated code should be written. Subdirectories will be created per language and submodule."})
    .option("genswitch", {alias: "s", describe: "Generates Elm modules containing switches for all given languages."})
    .option("language", {alias: "l", describe: "The language code of the current operation. This should match a file."})
    .option("root", {default: "Translation", describe: "The root to the translation modules. This script expects this directory to contain a file for each language."})
    .demand("language")
    .boolean("export")
		.option("runFormat", {default: false, describe: "Run elm-format on each of the generated Elm files (slow)."})
		.boolean("runFormat")
    .help()
    .argv;
const Elm = require("./dist/elm.js");
const fs = require("fs-extra");
const path = require("path");
const glob = require("glob");
const mkdirp = require("mkdirp");
const childProcess = require('child_process');
const tmp = require('tmp');

if (!argv.export && !argv.import && !argv.genswitch) {
    console.error("Please provide import, export or genswitch option");
    process.exit(403);
}

if (argv.format) {
		argv.format = argv.format.toLowerCase();
}

if (argv.exportOutput == "export") {
    argv.exportOutput = argv.exportOutput + "." + argv.format;
}

const currentDir = process.cwd();

if (argv.export) {
    let fullPath = path.join(currentDir, argv.root);
    console.log("Parsing from", fullPath);

    // read all files and store their content in an array
    let fileContents = readFiles(fullPath, "/**/{" + argv.language + "}.elm");

    // pass the array of file contents to our elm worker
    let worker = Elm.Elm.Main.init({
				"flags": {
						"languages": [],
						"sources": fileContents,
						"operation": "export",
						"format": argv.format
				}
    });

    // subscribe to the port to handle completion callback
    worker.ports.exportResult.subscribe(handleExport);
} else if (argv.import) {
    // ensure that import is a valid file path
    if (!argv.import || argv.import == "" || argv.import == true) {
        console.error("Please provide an import path");
        process.exit(403);
    }

    let pathToImport = path.join(currentDir, argv.import);

    let fileContents = readFiles(pathToImport, "{" + argv.language + "}/**/*." + argv.format);

    let worker = Elm.Elm.Main.init({
				"flags": {
						"languages": argv.language.split(","),
						"sources": fileContents,
						"operation": "import",
						"format": argv.format
				}
    });

    worker.ports.importResult.subscribe(handleImport);
} else {
    let fullPath = path.join(currentDir, argv.root);
    console.log("Parsing from", fullPath);
    let fileNames = glob.sync(fullPath + "/Translation/**/{"+argv.language+"}.elm");
    console.log("└── Found elm module files for export:", fileNames);

    // read all files and store their content in an array
    let fileContents = readFiles(fileNames);

    let worker = Elm.Elm.Main.init({
        "sources": fileContents,
        "operation": "genswitch",
        "languages": argv.language.split(","),
        "format": argv.format,
    });

    let importDir = path.join(currentDir, argv.importOutput, argv.root);
    worker.ports.importResult.subscribe(function(resultString) {
        handleImport(resultString, importDir);
    });
}


/**
 * handleExport - Handles the csv string generated by elm and saves it to exportOutput.
 *
 * @param  {String} resultString A CSV string of all translations.
 */
function handleExport([filePath, resultString]) {
    if (resultString === "") {
        process.exit(500);
    }

    let targetPath = path.join(currentDir, argv.exportOutput, filePath);
		writeFile(targetPath, resultString);
    console.log("Finished writing file to:", targetPath);
}

/**
 * handleImport - Handles the code generated by elm from a CSV file and writes
 * it to argv.importOutput/argv.language.
 *
 * @param  {[[String]]} results A list of (module name, file content) tuples.
 */
function handleImport([filePath, resultString]) {
    if (resultString === "") {
        process.exit(500);
    }

    let targetPath = path.join(currentDir, argv.importOutput, filePath);
		let directWrite = () => {writeFile(targetPath, resultString); }
		if (argv.runFormat) {
				let tmpfile = tmp.fileSync({template: "elm-i18n-XXXXXX.elm"});
				writeFile(tmpfile.name, resultString);
				let format = childProcess.spawnSync('elm-format', [tmpfile.name, '--yes', '--elm-version=0.19', "--output", targetPath]);
				if (format.error) {
						console.log("Could not format elm code:", format.error.message);
						directWrite();
				} else if (format.status && format.stderr) {
						console.log(format.stderr.toString());
						directWrite();
				}
		} else {
				directWrite();
		}
    console.log("Finished writing file to:", targetPath);
}


function readFiles(basePath, pattern) {
		let pat = path.join(basePath, pattern);
		return glob.sync(pat).map(function(file) {
				return [path.relative(basePath, file), fs.readFileSync(file).toString()];
		});
}

function writeFile(filePath, content) {
		mkdirp.sync(path.dirname(filePath));
    fs.writeFileSync(filePath, content);
}
